---
import { sortForMasonryLayout } from '@/functions';
import { checkModernFormats, getAvifPath, getWebpPath, getOptimizedSrc } from '@/utils/imageHelpers';

interface Props {
  images: {
    url: string;
    alt: string;
  }[];
}

const { images } = Astro.props;

// Pre-process images to check for modern formats
type ProcessedImage = {
  url: string;
  alt: string;
  shouldUsePicture: boolean;
  avifPath: string | null;
  webpPath: string | null;
  optimizedSrc: string;
};

const processedImages: ProcessedImage[] = images.map(img => {
  const { avifExists, webpExists } = checkModernFormats(img.url);
  const shouldUsePicture = avifExists && webpExists && (img.url.startsWith('/static/images/') || img.url.startsWith('static/images/'));
  return {
    ...img,
    shouldUsePicture,
    avifPath: shouldUsePicture ? getAvifPath(img.url) : null,
    webpPath: shouldUsePicture ? getWebpPath(img.url) : null,
    optimizedSrc: getOptimizedSrc(img.url),
  };
});
---

<section class="relative z-10 w-full overflow-visible">
  <div class="relative overflow-x-visible">
    <div
      class="max-w-none
        w-full md:w-[130%]
        -translate-x-0 md:-translate-x-[10%]
        mx-auto
        columns-1 sm:columns-2 lg:columns-3
        gap-2 space-y-2"
      id="gallery"
    >
      {sortForMasonryLayout(processedImages, 1).map((img, i) => (
        <div
          id={`overlay-${i}`}
          class="break-inside-avoid relative group cursor-pointer"
        >
          {img.shouldUsePicture ? (
            <picture>
              <source type="image/avif" srcset={img.avifPath} />
              <source type="image/webp" srcset={img.webpPath} />
              <img
                src={img.optimizedSrc}
                alt={img.alt}
                loading="lazy"
                class="w-full h-auto rounded-md"
                data-original-src={img.url}
              />
            </picture>
          ) : (
            <img
              src={img.optimizedSrc}
              alt={img.alt}
              loading="lazy"
              class="w-full h-auto rounded-md"
              data-original-src={img.url}
            />
          )}
          <div
            class="
              absolute bottom-0 left-0 right-0 px-3 py-2 text-xs
              text-white bg-black/60 rounded-b-md
              pointer-events-none
            "
          >
            {img.alt}
          </div>
        </div>
      ))}
    </div>
  </div>
</section>

<div
  id="overlay"
  class="fixed inset-0 z-10 flex items-center justify-center bg-black/0 p-4 opacity-0 pointer-events-none transition-opacity duration-300 data-[visible=true]:bg-black/60 data-[visible=true]:opacity-100 data-[visible=true]:pointer-events-auto"
  data-visible="false"
>
  <div
    class="relative shadow-black shadow-2xl opacity-0 scale-95 transition-all duration-300 ease-out data-[visible=true]:opacity-100 data-[visible=true]:scale-100"
    data-zoom-target
  >
    {processedImages[0]?.shouldUsePicture ? (
      <picture>
        <source type="image/avif" srcset={processedImages[0].avifPath} />
        <source type="image/webp" srcset={processedImages[0].webpPath} />
        <img
          src={processedImages[0].optimizedSrc}
          alt={processedImages[0].alt}
          loading="lazy"
          class="relative w-full h-auto max-w-full max-h-full sm:max-w-[70vw] sm:max-h-[70vh] rounded-md shadow-lg"
          data-original-src={processedImages[0].url}
        />
      </picture>
    ) : (
      <img
        src={processedImages[0]?.optimizedSrc || getOptimizedSrc(images[0].url)}
        alt={processedImages[0]?.alt || images[0].alt}
        loading="lazy"
        class="relative w-full h-auto max-w-full max-h-full sm:max-w-[70vw] sm:max-h-[70vh] rounded-md shadow-lg"
        data-original-src={processedImages[0]?.url || images[0].url}
      />
    )}
    <div
      class="absolute bottom-0 left-0 right-0 px-3 py-2 text-sm sm:text-md text-white bg-black/60 rounded-b-md pointer-events-none z-20"
    >
      ""
    </div>
  </div>
</div>

<script>
const imageElements = document.querySelectorAll('[id^="overlay-"]');
const overlay = document.getElementById('overlay') as HTMLElement;
const zoomTarget = overlay.querySelector('[data-zoom-target]') as HTMLElement;

imageElements.forEach((img) => {
  img.addEventListener('click', () => {
    if (!overlay || !zoomTarget) return;

    // Handle both picture and img elements
    const imageElement = img.querySelector('img') as HTMLImageElement;
    const alt = img.children[img.children.length - 1] as HTMLElement; // Alt div is last child

    const overlayPicture = zoomTarget.querySelector('picture');
    const overlayImage = overlayPicture 
      ? overlayPicture.querySelector('img') as HTMLImageElement
      : zoomTarget.querySelector('img') as HTMLImageElement;
    const overlayAlt = zoomTarget.children[zoomTarget.children.length - 1] as HTMLDivElement;

    if (imageElement && overlayImage) {
      // Use data-original-src if available, otherwise use current src
      const originalSrc = imageElement.getAttribute('data-original-src') || imageElement.src;
      
      // Update overlay picture sources if it exists
      if (overlayPicture) {
        const avifSource = overlayPicture.querySelector('source[type="image/avif"]') as HTMLSourceElement;
        const webpSource = overlayPicture.querySelector('source[type="image/webp"]') as HTMLSourceElement;
        
        if (avifSource) {
          const avifPath = originalSrc.replace(/\.(png|jpg|jpeg)$/i, '.avif');
          avifSource.srcset = avifPath;
        }
        if (webpSource) {
          const webpPath = originalSrc.replace(/\.(png|jpg|jpeg)$/i, '.webp');
          webpSource.srcset = webpPath;
        }
      }
      
      overlayImage.src = originalSrc;
      overlayImage.alt = alt.textContent || '';
      overlayAlt.textContent = alt.textContent || '';
    }

    overlay.dataset.visible = 'true';
    zoomTarget.dataset.visible = 'true'; // needed to trigger zoom
  });
});

overlay?.addEventListener('click', () => {
  overlay.dataset.visible = 'false';
  zoomTarget?.removeAttribute('data-visible');
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    overlay.dataset.visible = 'false';
    zoomTarget?.removeAttribute('data-visible');
  }
});
</script>